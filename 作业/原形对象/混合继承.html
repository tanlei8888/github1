<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
     //混合继承
      //使用call来继承静态属性
      //使用原型链来继承动态方法
    function Person(name,age) {
        this.name = name;
        this.age = age;
    }
    Person.prototype.fn = function(){
        return this.name+"在写代码";
    }
    Person.prototype.fn1 = function(){
        return "今年"+this.age+"岁";
    }

    let P1 = new Person("谭磊",24)

    console.log(P1);
    console.log(P1.fn());
    console.log(P1.fn1());

    //--------------------------------------------------------------------
    function Hobby(name,age,sing){
    //继承静态属性的方法 继承了上面Person的静态属性,name,age
        Person.call(this,name,age)
        this.hobby = sing;
    }

    //继承原型方法的方法 继承了上面的Person的fn(),fn1()
    Hobby.prototype = new Person();
    Hobby.prototype.fn2 = function(){
        return "我喜欢"+this.hobby;
    }
    Hobby.prototype.fn1 = function(){
        return "今年"+this.age+"岁"+"奔三了";
    }

    let H1 = new Hobby("谭磊","24","唱歌");
    console.log(H1);
    console.log(H1.fn());
    console.log(H1.fn1());//输出今年24岁奔三了 就近原则 如果自身没有才会向上级查找输出
    console.log(H1.fn2());
</script>
</html>